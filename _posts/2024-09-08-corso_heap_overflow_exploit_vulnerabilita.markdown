---
layout: post
title:  "Corso Heap Overflow: Exploit di Vulnerabilità Heap Overflow"
date:   2024-09-08 14:00:00 +0200
categories: heap-overflow
tags: [heap-overflow, exploit, vulnerabilità, overflow]
---

# Corso Heap Overflow: Exploit di Vulnerabilità Heap Overflow

Ora che abbiamo una buona comprensione di come funziona l'allocazione dell'heap e di come si verifica un heap overflow, è il momento di passare all'argomento chiave: **sfruttare una vulnerabilità di heap overflow**. In questa lezione, ci concentreremo sulle tecniche utilizzate per sfruttare questa vulnerabilità e sulle metodologie di attacco classiche.

## 1. Obiettivi di un Exploit di Heap Overflow

Un heap overflow non sfruttato correttamente può causare un crash del programma senza alcun risultato utile. Tuttavia, quando sfruttato adeguatamente, un heap overflow può consentire di:

- **Corrompere la gestione dell'heap**: Sovrascrivere i puntatori e le strutture di dati interne dell'heap per alterare il comportamento del programma.
- **Esecuzione di codice arbitrario**: Manipolando i puntatori nell'heap, è possibile redirigere il flusso di esecuzione del programma e fare in modo che esegua codice malevolo.
- **Bypass di protezioni di sicurezza**: Tecniche come il **heap spraying** possono essere utilizzate per aggirare protezioni come DEP (Data Execution Prevention) e ASLR (Address Space Layout Randomization).

## 2. Sovrascrittura del Chunk Header

Come discusso nella lezione precedente, un attacco di heap overflow comporta spesso la sovrascrittura dell'header del chunk. Quando si libera un chunk con l'header corrotto, i puntatori avanti e indietro vengono utilizzati per manipolare la memoria interna e condurre l'attacco.

### Unlink Attack: Sovrascrivere Puntatori

Uno degli attacchi più classici contro una vulnerabilità di heap overflow è l'**Unlink Attack**. Questo attacco sfrutta la sovrascrittura dei puntatori dell'header di un chunk libero, modificando i puntatori **forward** e **backward**.

#### Esempio Pratico

In un'allocazione tipica, quando un chunk viene liberato, i suoi puntatori **forward** e **backward** puntano ai chunk successivi e precedenti nella lista dei chunk liberi:

```
+------------------+    +------------------+    +------------------+
| Chunk Precedente  |<-->|     Chunk 1      |<-->|   Chunk Successivo|
|  (free)           |    |  (free)          |    |  (free)           |
+------------------+    +------------------+    +------------------+
|    Punt. Backward |    | Punt. Forward    |    | Punt. Forward     |
|    Punt. Forward  |    | Punt. Backward   |    | Punt. Backward    |
+------------------+    +------------------+    +------------------+
```

Quando si verifica un heap overflow e si sovrascrivono i puntatori **forward** e **backward**, è possibile far sì che, al momento della liberazione del chunk, il programma modifichi porzioni di memoria critiche. Ad esempio, puoi puntare uno dei puntatori su una variabile che desideri sovrascrivere con dati specifici.

```c
// Allocazione di chunk nell'heap
char *chunk1 = malloc(64);
char *chunk2 = malloc(64);

// Sovrascrittura dei dati in chunk1 per corrompere l'header di chunk2
memcpy(chunk1, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", 80);
```

Nel momento in cui `chunk2` viene liberato, i puntatori corrotti possono essere utilizzati per manipolare la memoria.

## 3. Fastbin Duplication: Manipolare i Fastbin

Un'altra tecnica comune per sfruttare le vulnerabilità di heap overflow su Linux (specificamente con **ptmalloc**) è il **Fastbin Duplication Attack**. Questa tecnica sfrutta i fastbin, che sono piccole liste di chunk recentemente liberati, per allocare blocchi duplicati e sovrascrivere aree critiche.

### Esempio di Fastbin Duplication Attack

1. **Allocazione di due chunk**: Allocare due chunk nell'heap e quindi liberare uno dei due.
2. **Corrompere i puntatori del fastbin**: Usare un heap overflow per corrompere i puntatori nel fastbin in modo che puntino a una posizione desiderata.
3. **Riallocazione dei chunk**: Quando il chunk viene riassegnato, il programma creerà un'allocazione duplicata nella posizione desiderata, sovrascrivendo porzioni di memoria sensibili.

```c
char *a = malloc(64);
char *b = malloc(64);
free(a);

// Sovrascrivi il puntatore fastbin di a per puntare a una posizione desiderata
memcpy(b, "......", sizeof(a)); // Puntatore manipolato
```

### Heap Spraying

Una tecnica avanzata e spesso utilizzata insieme ad altri tipi di overflow è lo **heap spraying**. Lo heap spraying è una tecnica che prevede il riempimento di grandi porzioni di heap con dati controllati dall'attaccante, con l'obiettivo di piazzare codice malevolo in posizioni prevedibili della memoria. Una volta che si conosce la posizione della memoria sprayata, è possibile farvi saltare il flusso di esecuzione per eseguire il codice iniettato.

#### Esempio di Heap Spraying in JavaScript

Lo heap spraying può essere utilizzato anche nel contesto del browser, sfruttando il JavaScript per riempire l'heap con shellcode:

```javascript
var heapSpray = unescape("%u9090%u9090...%ucall%ueax");
var heapBlock = new Array();

for (var i = 0; i < 1000; i++) {
    heapBlock[i] = heapSpray + unescape("%u9090");
}
```

## 4. Exploit di Vulnerabilità Real-World

Per comprendere meglio come funziona uno heap overflow nella pratica, analizziamo un caso reale:

- **CVE-2016-0728**: Una vulnerabilità heap overflow trovata nel kernel Linux che permetteva di eseguire codice arbitrario. La vulnerabilità si trovava nella gestione dei keyrings di Linux, e un attaccante poteva sfruttare un heap overflow per elevare i privilegi fino a ottenere un root shell.

## 5. Protezioni Moderne e Bypass

Molti sistemi moderni implementano protezioni per mitigare gli attacchi basati su heap overflow. Le protezioni comuni includono:

- **ASLR (Address Space Layout Randomization)**: Cambia casualmente l'indirizzo dell'heap per rendere più difficile prevedere dove si trova il codice iniettato.
- **DEP (Data Execution Prevention)**: Impedisce l'esecuzione di codice dall'heap.

Tuttavia, esistono tecniche per bypassare queste protezioni. Ad esempio:

- **Return-Oriented Programming (ROP)**: Invece di iniettare codice nell'heap, un attaccante può sfruttare i frammenti di codice esistenti (gadget) per costruire una catena di exploit.

## Conclusione

Le vulnerabilità di heap overflow rappresentano un problema complesso e interessante nel campo della sicurezza informatica. Sebbene le protezioni moderne abbiano reso più difficile sfruttare tali vulnerabilità, tecniche avanzate come il ROP e il heap spraying possono ancora essere efficaci. Nella prossima lezione, approfondiremo le tecniche di bypass delle protezioni e vedremo come combinare le conoscenze apprese per creare exploit completi.

